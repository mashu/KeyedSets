var documenterSearchIndex = {"docs":
[{"location":"#KeyedSets","page":"Home","title":"KeyedSets","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for KeyedSets. The latest docs are deployed from the main branch as stable.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeyedSets provides a type-stable, parametric KeyedSet{S,N} that stores unique sequences of type S with associated names of type N. It supports set-like operations while collecting detailed conflict information about duplicates, same-sequence/different-name, and same-name/different-sequence situations.","category":"page"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeyedPair{S,N}: container of a sequence::S and name::N.\nKeyedSet{S,N}: mapping of sequence to name.\nConflictSummary{S,N}: captures conflicts detected during operations.","category":"page"},{"location":"#Constructors","page":"Home","title":"Constructors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"KeyedSet{S,N}() creates an empty set.\nKeyedSet(pairs) constructs and infers S and N from the first element. Elements can be KeyedPair{S,N} or (sequence::S, name::N) tuples.","category":"page"},{"location":"#Operations","page":"Home","title":"Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"union(a, b) / union_with_conflicts(a, b)\nintersect(a, b) / intersect_with_conflicts(a, b)\nsetdiff(a, b) / setdiff_with_conflicts(a, b)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The _with_conflicts variants return (result, conflicts::ConflictSummary). The Base-overrides return only result and log conflicts.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using KeyedSets\n\n\"\"\"\nDNA example: sequences as Strings, names as Strings\n\"\"\"\na = KeyedSet([(\"ACGT\", \"seq1\"), (\"AAA\", \"alpha\")])\nb = KeyedSet([(\"AAA\", \"alpha2\"), (\"TTT\", \"beta\")])\n\nres, conf = union_with_conflicts(a, b)\ncollect(sequences(res))         # => [\"ACGT\", \"AAA\", \"TTT\"] (order not guaranteed)\nres[\"AAA\"]                      # => \"alpha\" (left wins)\nconf.sequence_name_mismatches   # => [(\"AAA\", \"alpha\", \"alpha2\")]","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#KeyedSets.ConflictSummary","page":"Home","title":"KeyedSets.ConflictSummary","text":"ConflictSummary{S,N}\n\nSummary of conflicts detected during set-like operations.\n\nFields:\n\nduplicates::Vector{KeyedPair{S,N}} — same sequence and name present in both sides\nsequence_name_mismatches::Vector{Tuple{S,N,N}} — same sequence but different names (sequence, left_name, right_name)\nname_collisions::Vector{Tuple{N,S,S}} — same name used for different sequences (name, left_sequence, right_sequence)\n\n\n\n\n\n","category":"type"},{"location":"#KeyedSets.KeyedPair","page":"Home","title":"KeyedSets.KeyedPair","text":"KeyedPair{S,N}\n\nPair of a sequence and its human-readable name.\n\nFields:\n\nsequence::S\nname::N\n\n\n\n\n\n","category":"type"},{"location":"#KeyedSets.KeyedSet","page":"Home","title":"KeyedSets.KeyedSet","text":"KeyedSet{S,N,D<:AbstractDict{S,N}}\n\nA collection that maps a sequence (key) to a name (value). Behaves like a set of sequences for set-like operations, while tracking names and reporting conflicts.\n\nInternally stores data::D, an AbstractDict{S,N} mapping sequence => name.\n\n\n\n\n\n","category":"type"},{"location":"#KeyedSets.KeyedSet-Union{Tuple{}, Tuple{N}, Tuple{S}} where {S, N}","page":"Home","title":"KeyedSets.KeyedSet","text":"KeyedSet{S,N}()\nKeyedSet{S,N}(pairs)\nKeyedSet(pairs)\n\nConstruct an empty KeyedSet{S,N} or from an iterable of pairs.\n\nAccepted element forms in pairs:\n\nKeyedPair{S,N}\n(sequence::S, name::N) tuple\n\n\n\n\n\n","category":"method"},{"location":"#Base.:==-Union{Tuple{N}, Tuple{S}, Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}, KeyedSet{S, N, D} where D<:AbstractDict{S, N}}} where {S, N}","page":"Home","title":"Base.:==","text":"Base.:(==)(a::KeyedSet, b::KeyedSet)\n\nEquality is based on the set of sequences only (names are ignored). This implementation avoids temporary set allocation.\n\n\n\n\n\n","category":"method"},{"location":"#Base.empty-Union{Tuple{KeyedSet{S, N, D}}, Tuple{D}, Tuple{N}, Tuple{S}} where {S, N, D<:AbstractDict{S, N}}","page":"Home","title":"Base.empty","text":"Base.empty(ks::KeyedSet)\n\nReturn a new empty KeyedSet with the same type parameters and backing storage type as ks.\n\n\n\n\n\n","category":"method"},{"location":"#Base.push!-Union{Tuple{N}, Tuple{S}, Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}, KeyedPair{S, N}}} where {S, N}","page":"Home","title":"Base.push!","text":"push!(ks::KeyedSet, kp)\n\nInsert a KeyedPair or (sequence, name) into the set. If the sequence exists with a different name, the existing name is kept and a message is logged.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets._name_to_sequences-Union{Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}}, Tuple{N}, Tuple{S}} where {S, N}","page":"Home","title":"KeyedSets._name_to_sequences","text":"_name_to_sequences(ks)\n\nBuild a mapping from name to the set of sequences using that name.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets.intersect_with_conflicts-Union{Tuple{N}, Tuple{S}, Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}, KeyedSet{S, N, D} where D<:AbstractDict{S, N}}} where {S, N}","page":"Home","title":"KeyedSets.intersect_with_conflicts","text":"intersect_with_conflicts(left::KeyedSet, right::KeyedSet)\n\nIntersection by sequences. If names differ, the name from left is used. Conflicts are returned in ConflictSummary.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets.names-Tuple{KeyedSet}","page":"Home","title":"KeyedSets.names","text":"names(ks)\n\nReturn an iterator over names stored in the set.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets.sequences-Tuple{KeyedSet}","page":"Home","title":"KeyedSets.sequences","text":"sequences(ks)\n\nReturn an iterator over sequences contained in the set.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets.setdiff_with_conflicts-Union{Tuple{N}, Tuple{S}, Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}, KeyedSet{S, N, D} where D<:AbstractDict{S, N}}} where {S, N}","page":"Home","title":"KeyedSets.setdiff_with_conflicts","text":"setdiff_with_conflicts(left::KeyedSet, right::KeyedSet)\n\nSet difference by sequences: elements in left not in right. When a name from left exists in right but for a different sequence, a name collision is reported.\n\n\n\n\n\n","category":"method"},{"location":"#KeyedSets.union_with_conflicts-Union{Tuple{N}, Tuple{S}, Tuple{KeyedSet{S, N, D} where D<:AbstractDict{S, N}, KeyedSet{S, N, D} where D<:AbstractDict{S, N}}} where {S, N}","page":"Home","title":"KeyedSets.union_with_conflicts","text":"union_with_conflicts(left::KeyedSet, right::KeyedSet) -> (result, conflicts)\n\nUnion by sequences. If a sequence exists on both sides with different names, the name from left is kept. Conflicts are returned in ConflictSummary.\n\n\n\n\n\n","category":"method"}]
}
